## 工厂方法
&emsp;&emsp;别名：虚构造器<br>
&emsp;&emsp;定义：定义一个创建对象的接口，让子类来决定如何创建对象那个。<br>
&emsp;&emsp;适用场景:<br>
* 当无法预料何时必须创建对象的时候
* 当期望它的子类定义如何创建对象的时候
* 将类的创建责任分配给子类<br>

&emsp;&emsp;优点：<br>
* 基类提供抽象接口，由子类实现创建工作
* 连接并行类层次<br>

&emsp;&emsp;缺点：<br>
* 需要基类构造器和相应的子类作为工厂方法的载体，如果应用模型确实需要基类构造器和子类存在，则很好。否则的话，需要增加一个类层次.<br>

## 抽象工厂
&emsp;&emsp;解决一族相关或者相依对象的创建工作，专门定义一个用于创建这类对象的接口(基类)。客户只需要与这个接口打交道，不必考虑实体类的实现细节就好.<br>

&emsp;&emsp;使用场景:当满足以下条件时<br>
* 系统应该独立于它的产品是如何创建，组成和表现<br>
* 系统被许多产品族中的一种配置
* 当一族相关对象被设计于共同使用，而且需要加强这种约束时
* 当需要提供一个类库而且仅仅想暴露它们的接口而不是实现时。<br>

&emsp;&emsp;优点:<br>
* 工厂把产品的类型封装起来，分离了具体的类
* 易于变换产品类
* 保证不同族之间的产品相互不会碰撞，即保证产品的一致

&emsp;&emsp;缺点:<br>
* 工厂对象的工厂方法数目对应产品种类数目，增加产品种类比较困难，要影响到工厂基类，进而影响所有子类.<br>

## 原型模式
&emsp;&emsp;定义:<br>
&emsp;&emsp;&emsp;使用一个原型定义要创建的物体种类，创建新对象是通过复制这个原型完成的。<br>
&emsp;&emsp;以一个已有的对象作为原型，通过它来创建新的对象。在增加新的对象的时候，新对象的细节创建工作由自己来负责，从而使新对象的创建过程与框架隔离开。<br>
&emsp;&emsp;适用场景：<be>
* 当产品的创建过程要独立于系统时
* 当产品的类型是在运行时指定的情况下
* 避免创建一个与产品层次平行的工厂层次时
* 当产品类的实例只能是几种确定的不同实例状态中的一种时<br>

## 单例模式
&emsp;&emsp;确保一个类只有一个实例，而且提供一个全局的访问点。<br>
&emsp;&emsp;适用场景:<br>
* 一个类必须只能有一个实例时，而且它必须提供一个全局访问点时
* 当唯一的实例被拓展而却客户想要在不修改代码的情况下使用扩展后的实例<br>
<br>
<center>
Copyleft&copy; by 寒江雪1719<br>
Date:2017.6.14<be>
</center>
